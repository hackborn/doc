package parser

import (
	"strconv"
	"strings"
)

// ------------------------------------------------------------
// NODE-T

func newNode(s symbol, text string) *nodeT {
	token, ok := tokenMap[s]
	if !ok {
		token = tokenMap[illegalToken]
	}
	return &nodeT{Token: token, Text: text}
}

// nodeT serves two purposes: it is a token generated by the
// lexer, and it is a node in the tree constructed by the parser.
type nodeT struct {
	// Lexing
	Token *tokenT
	Text  string

	// Parsing
	Parent *nodeT `json:"-"`
	// XXX Note: This has stayed here because I really want to
	// remove the overhead of allocating a slice while building
	// the tree. For the whole time, no nodes can have more than
	// two children and I've been able to do that, but I suspect
	// future functions will require a child list.
	//	Left     *node_t
	//	Right    *node_t
	Children []*nodeT `json:"omitempty"`
}

// reclassify converts this token into one of the defined
// keywords, if appropriate. Ideally this is done directly
// in the scanning stage, but I'm not sure how to get the
// scanner to do that.
func (n *nodeT) reclassify() *nodeT {
	if n.Token.Symbol != stringToken {
		return n
	}
	upper := strings.ToUpper(n.Text)
	if found, ok := keywordMap[upper]; ok {
		return newNode(found.Symbol, n.Text)
	}
	return n
}

func (n *nodeT) addChild(child *nodeT) {
	n.Children = append(n.Children, child)
	child.Parent = n
}

// asAst returns the AST node for this tree node.
func (n *nodeT) asAst() (AstNode, error) {
	// fmt.Println("ast", n.Text)
	switch n.Token.Symbol {
	case eqlToken, neqToken, andToken, orToken, assignToken, listToken:
		lhs, rhs, err := n.makeBinary()
		if err != nil {
			return nil, err
		}
		return &binaryNode{Op: n.Token.Symbol, Keyword: n.Token.Text, Lhs: lhs, Rhs: rhs}, nil
	case floatToken:
		if len(n.Children) != 0 {
			return nil, newParseError("float has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		f64, err := strconv.ParseFloat(n.Text, 64)
		if err != nil {
			return nil, err
		}
		return &valueNode{Value: f64}, nil
	case intToken:
		if len(n.Children) != 0 {
			return nil, newParseError("int has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		i, err := strconv.ParseInt(n.Text, 10, 32)
		if err != nil {
			return nil, err
		}
		return &valueNode{Value: int(i)}, nil
	case openToken:
		child, err := n.makeUnary()
		if err != nil {
			return nil, err
		}
		return &unaryNode{Op: openToken, Child: child}, nil
	case stringToken:
		if len(n.Children) != 0 {
			return nil, newParseError("string has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		// Unwrap quoted text, which has served its purpose of allowing special characters.
		text := strings.Trim(n.Text, `"`)
		return &valueNode{Value: text}, nil
	}
	return nil, newParseError("on unknown token: " + strconv.Itoa(int(n.Token.Symbol)) + ", " + n.Token.Text)
}

func (n *nodeT) makeBinary() (AstNode, AstNode, error) {
	if len(n.Children) != 2 {
		return nil, nil, newParseError("binary has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
	lhs, err := n.Children[0].asAst()
	if err != nil {
		return nil, nil, err
	}
	rhs, err := n.Children[1].asAst()
	if err != nil {
		return nil, nil, err
	}
	return lhs, rhs, nil
}

func (n *nodeT) makeUnary() (AstNode, error) {
	if len(n.Children) != 1 {
		return nil, newParseError("unary has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
	return n.Children[0].asAst()
}
